\subchapter
{Advanced aspects}
{Objectives:
  \begin{itemize}
  \item Use build time, dependency and filesystem size graphing capabilities
  \item Use licensing report generation, and add licensing
    information to your own packages
  \item Use \code{BR2_EXTERNAL}
  \end{itemize}
}

\section{Build time graphing}

When your embedded Linux system grows, its build time will also grow,
so it is often interesting to understand where the build time is
spent.

Since we have just do a fresh clean rebuild at the end of the previous
lab, we can analyze the build time. The raw data has been generated by
Buildroot in \code{output/build/build-time.log}, which contains for
each step of each package the start time and end time (in seconds
since Epoch).

Now, let's get a better visualization of this raw data:

\begin{verbatim}
make graph-build
\end{verbatim}

Note: you may need to install \code{python-matplotlib} on your machine.

The graphs are generated in \code{output/graphs}:

\begin{itemize}
\item \code{build.hist-build.pdf}, build time of each package, by
  build order
\item \code{build.hist-duration.pdf}, build time of each package, by
  build duration
\item \code{build.hist-name.pdf}, build time of each package, by
  package name
\item \code{build.pie-packages.pdf}, build time of each package, in
  proportion of the total build time
\item \code{build.pie-steps.pdf}, build time of each step
\end{itemize}

Explore those graphs, see which packages and steps are taking the
biggest amount of time.

Note that when you don't do a clean rebuild, the \code{build-time.log}
file gets appended and appended with all the successful builds, making
the resulting graphs unexploitable. So remember to always do a clean
full rebuild before looking at the build time graphs.

\section{Dependency graphing}

Another useful tool to analyze the build is graphing dependencies
between packages. The dependency graph is generated for your current
configuration: depending on the Buildroot configuration, a given
package may have different dependencies.

To generate the full dependency graph, do:

\begin{verbatim}
make graph-depends
\end{verbatim}

The graph is also generated in \code{output/graphs}, under the name
\code{graph-depends.pdf}. On the graph, identify the \code{bar} and
\code{ninvaders} packages you have created, and look at their
dependencies to see if they match your expectations.

Now, let's draw a graph for a much bigger system. To do this, create a
completely separate Buildroot output directory:

\begin{verbatim}
mkdir $HOME/felabs/buildroot-output-test-graph/
cd $HOME/felabs/buildroot-output-test-graph/
\end{verbatim}

We're going to create a Buildroot configuration, so create a file
named \code{.config} and put the following contents:

\begin{verbatim}
BR2_TOOLCHAIN_BUILDROOT_LARGEFILE=y
BR2_TOOLCHAIN_BUILDROOT_INET_IPV6=y
BR2_TOOLCHAIN_BUILDROOT_INET_RPC=y
BR2_TOOLCHAIN_BUILDROOT_WCHAR=y
BR2_TOOLCHAIN_BUILDROOT_CXX=y
BR2_PACKAGE_XORG7=y
BR2_PACKAGE_XSERVER_XORG_SERVER=y
BR2_PACKAGE_LIBGTK2=y
BR2_PACKAGE_WEBKIT=y
\end{verbatim}

It represents a configuration that builds an internal toolchain, with
a X.org graphic server, the Gtk2 library, and the Webkit Web rendering
engine. We're not going to build this configuration, as it would take
quite a bit of time, but we will generate the dependency graph for it.

First, let's run \code{make menuconfig} to expand this minimal
configuration into a full configuration:

\begin{verbatim}
make -C $HOME/felabs/buildroot/ O=$(pwd) menuconfig
\end{verbatim}

Feel free to explore the configuration at this stage. Now, let's
generate the dependency graph:

\begin{verbatim}
make graph-depends
\end{verbatim}

Look at \code{graphs/graph-depends.pdf} and how complex it is. Now,
let's look at the dependencies of one specific package, let's say
\code{libgtk2}:

\begin{verbatim}
make libgtk2-graph-depends
\end{verbatim}

Now, open the graph generated at
\code{graphs/libgtk2-graph-depends.pdf}. As you can see, it is a lot
more readable.

Such dependencies graphs are very useful to understand why a package
is being built, and help identifying what you could do to reduce the
number of packages part of the build.

\section{Filesystem size graphing}

Run \code{make graph-size} and watch the PDF generated at
\code{output/graphs/graph-size.pdf}. You can also look at the CSV
files generated in \code{output/graphs/}.

\section{Licensing report}

Go back to our original build directory, in
\code{$HOME/felabs/buildroot/}.

As explained during the lectures, Buildroot has a built-in mechanism
to generate a licensing report, describing all the components part of
the generated embedded Linux system, and their corresponding licenses.

Let's generate this report for our system:

\begin{verbatim}
make legal-info
\end{verbatim}

In the output, you can see some interesting messages:

\begin{verbatim}
WARNING: bar: cannot save license (BAR_LICENSE_FILES not defined)
WARNING: libfoo: cannot save license (LIBFOO_LICENSE_FILES not defined)
WARNING: ninvaders: cannot save license (NINVADERS_LICENSE_FILES not defined)
\end{verbatim}

So, now update your \code{ninvaders}, \code{libfoo} and \code{bar}
packages to include license information. Run again \code{make
  legal-info}.

Now, explore \code{output/legal-info}, look at the \code{.csv} files,
the \code{.txt} files, and the various directories. Buildroot has
gathered for you most of what is needed to help with licensing
compliance.

\section{Use {\tt BR2\_EXTERNAL}}

We should have used \code{BR2_EXTERNAL} since the beginning of the
training, but we were busy learning about so many other things! So
it's finally time to use \code{BR2_EXTERNAL}.

The whole point of \code{BR2_EXTERNAL} is to allow storing your
project-specific packages, configuration files, root filesystem
overlay or patches outside of the Buildroot tree itself. It makes it
easier to separate the open-source packages from the proprietary ones,
and it makes updating Buildroot itself a lot simpler.

So, as recommended in the slides, the goal now is to use
\code{BR2_EXTERNAL} to move away from the main Buildroot tree the
following elements:

\begin{itemize}

\item The \code{bar} and \code{libfoo} packages. We will keep the
  \code{ninvaders} package in the Buildroot tree, since it's a
  publicly available open-source package, so it should be submitted to
  the official Buildroot rather than kept in a \code{BR2_EXTERNAL}
  tree.

\item The Linux kernel patch and Linux kernel configuration file. For
  the Linux kernel patch, use \code{BR2_GLOBAL_PATCH_DIR} instead of
  the Linux-specific \code{BR2_LINUX_KERNEL_PATCH} option.

\item The {\em rootfs overlay}

\item The {\em post-build script}

\item The {\em defconfig}

\end{itemize}

Your \code{BR2_EXTERNAL} tree should look like this:

\begin{verbatim}
+-- board/
|   +-- felabs/
|       +-- beagleboneblack/
|           +-- linux.config
|           +-- post-build.sh
|           +-- patches/
|               +-- linux/
|                   +-- 0001-Add-nunchuk-driver.patch
|                   +-- 0002-Add-i2c1-and-nunchuk-nodes-in-dts.patch
|           +-- rootfs-overlay/
|               +-- etc
|                   +-- network
|                       +-- interfaces
+-- package/
|   +-- bar
|       +-- bar.mk
|       +-- Config.in
|   +-- libfoo
|       +-- libfoo.mk
|       +-- Config.in
+-- configs
|   +-- felabs_defconfig
+-- Config.in
+-- external.mk
\end{verbatim}

Now, do a full rebuild using your \code{BR2_EXTERNAL} tree, and check
that your system builds and runs fine!

