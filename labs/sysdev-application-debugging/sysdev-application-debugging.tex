\subchapter{Remote application debugging}{Objective: Use \code{strace}
  to diagnose program issues. Use \code{gdbserver} and a
  cross-debugger to remotely debug an embedded application}

\section{Setup}

Go to the \code{$HOME/embedded-linux-labs/debugging} directory.
Create an \code{nfsroot} directory.

\section{Debugging setup}

Reuse the Buildroot 2016.02 sources:
\begin{verbatim}
cp -a $HOME/embedded-linux-labs/buildroot/buildroot-2016.02 .
\end{verbatim}
Instead of using the toolchain we compiled, we are going to use an
external toolchain from Linaro. Indeed gdb is buggy when built with
the toolchain we created: it uses a too old version of uClibc.

From the directory
\code{$HOME/embedded-linux-labs/debugging/buildroot-2016.02},
cleanup the binaries:
\begin{verbatim}
make clean
\end{verbatim}
then configure buildroot with the following modification:

\begin{itemize}
\item In \code{Toolchain}:
   \begin{itemize}
   \item \code{Toolchain type}: \code{External toolchain}
   \item \code{Toolchain}: \code{Linaro ARM 2015.11}
   \item \code{Toolchain origin}: \code{Toolchain to be downloaded and installed}
   \item Select \code{Copy gdb server to the Target}
   \end{itemize}
 \item \code{Target packages}
   \begin{itemize}
   \item \code{Debugging, profiling and benchmark}
     \begin{itemize}
     \item Select \code{ltrace}
     \item Select \code{strace}
     \end{itemize}
   \end{itemize}
\end{itemize}

Now, build your root filesystem.

Go back to the \code{$HOME/embedded-linux-labs/debugging} directory
and extract the \code{buildroot-2016.02/output/images/rootfs.tar}
archive in the \code{nfsroot} directory.

Update the \code{/etc/exports} file and restart the
\code{nfs-kernel-server}.

Boot your ARM board over NFS on the filesystem produced with the same
kernel.

\section{Using strace}

Now, go to the \code{$HOME/embedded-linux-labs/debugging} directory.

\code{strace} allows to trace all the system calls made by a process:
opening, reading and writing files, starting other processes,
accessing time, etc. When something goes wrong in your application,
strace is an invaluable tool to see what it actually does, even when
you don't have the source code.


Update the PATH:
\footnotesize
\begin{verbatim}
export PATH=$HOME/embedded-linux-labs/buildroot/buildroot-2016.02/output/host/usr/bin:$PATH
\end{verbatim}
\normalsize

With your cross-compiling toolchain, compile the
\code{data/vista-emulator.c} program, strip it with
\code{arm-linux-gnueabihf-strip}, and copy the resulting binary to the
\code{/root} directory of the root filesystem.

Back to target system, try to run the \code{/root/vista-emulator}
program. It should hang indefinitely!

Interrupt this program by hitting \code{[Ctrl] [C]}.

Now, running this program again through the \code{strace} command and
understand why it hangs. You can guess it without reading the source
code!

Now add what the program was waiting for, and now see your program
proceed to another bug, failing with a segmentation fault.

\section{Using ltrace}

Now run the program through \code{ltrace}.

Now you should see what the program does: it tries to consume as much
system memory as it can!

\section{Using gdbserver}

We are now going to use \code{gdbserver} to understand why the program
segfaults.

Compile \code{vista-emulator.c} again with the \code{-g} option to
include debugging symbols. This time, just keep it on your workstation,
as you already have the version without debugging symbols on your target.

Then, on the target side, run \code{vista-emulator} under
\code{gdbserver}. \code{gdbserver} will listen on a TCP port for a
connection from \code{gdb}, and will control the execution of
\code{vista-emulator} according to the \code{gdb} commands:

\begin{verbatim}
gdbserver localhost:2345 vista-emulator
\end{verbatim}

On the host side, run \code{arm-linux-gnueabihf-gdb} (also found in your toolchain):
\begin{verbatim}
arm-linux-gnueabihf-gdb vista-emulator
\end{verbatim}

You can also start the debugger through the \code{ddd} interface:
\begin{verbatim}
ddd --debugger arm-linux-gnueabihf-gdb vista-emulator
\end{verbatim}

\code{gdb} starts and loads the debugging information from the
\code{vista-emulator} binary that has been compiled with \code{-g}.

Then, we need to tell where to find our libraries, since they are not
present in the default \code{/lib} and \code{/usr/lib} directories on
your workstation. This is done by setting the \code{gdb} \code{sysroot}
variable (on one line):

\begin{verbatim}
(gdb) set sysroot /home/<user>/embedded-linux-labs/debugging/
buildroot-XXXX.YY/output/staging
\end{verbatim}

And tell \code{gdb} to connect to the remote system:
\begin{verbatim}
(gdb) target remote <target-ip-address>:2345
\end{verbatim}

Then, use \code{gdb} as usual to set breakpoints, look at the source
code, run the application step by step, etc. Graphical versions of
\code{gdb}, such as \code{ddd} can also be used in the same way.
In our case, we'll just start the program and wait for it to hit
the segmentation fault:
\begin{verbatim}
(gdb) continue
\end{verbatim}

You could then ask for a backtrace to see where this happened:
\begin{verbatim}
(gdb) backtrace
\end{verbatim}

This will tell you that the segmentation fault occurred in a function
of the C library, called by our program. This should help you in
finding the bug in our application.

\section{What to remember}

During this lab, we learned that...
\begin{itemize}

\item It's easy to study the behavior of programs and diagnose issues
%  without even having the source code, thanks to strace and ltrace.
  without even having the source code, thanks to strace.

\item You can leave a small \code{gdbserver} program (300 KB) on your target
  that allows to debug target applications, using a standard \code{gdb}
  debugger on the development host.

\item It is fine to strip applications and binaries on the target
  machine, as long as the programs and libraries with debugging
  symbols are available on the development host.

\end{itemize}

