\subchapter
{Autotools basics}
{Objectives:
  \begin{itemize}
  \item Your first {\tt configure.ac}
  \item Adding and building a program
  \item Going further: \code{autoscan} and \code{make dist}
  \end{itemize}
}

\section{Create your first {\tt configure.ac}}

In \code{$HOME} (or the directory you created for this training),
create a new folder \code{project} for your first {\em autotools}
project.

In order to keep a good understanding of real source files as opposed
to generated files, we'll put our project under version control, using
{\em Git}. Run \code{git init} to initialize a new repository.

Create the absolutely minimal \code{configure.ac} using just
\code{AC_INIT} and \code{AC_OUTPUT}. Use \code{git add configure.ac}
to add this file to the Git repository, and
\code{git commit -s -m "Initial configure.ac"} to commit this first
\code{configure.ac}.

Use \code{autoreconf -i}, look at which files where generated. Thanks
to \code{git status}, you can see which of those files are not under
version control.

Test your shiny new \code{configure} script. How much does it do? Look
at the new files that have been generated.

Now, prepare your project to support C source code, by adding
\code{AC_PROG_CC} to your \code{configure.ac}. Run
\code{autoreconf -i} again, and restart \code{./configure}. It should
do a lot more tests now!

\section{Adding and building a program}

Create a very simple hello world C program in a file called
\code{hello.c}:

\begin{verbatim}
#include <stdio.h>

int main(void) {
   printf("Hello World\n");
   return 0;
}
\end{verbatim}

In order to build this file, you'll have to adjust your
\code{configure.ac} to initialize \code{automake} and create a
\code{Makefile.am} file with the necessary code to build one program.

Run \code{autoreconf -i}, and once it {\em autoreconfs} properly,
build your project!

You can also install it, after re-configuring it with
\code{--prefix=$HOME/sys}.

As you can see, doing your first {\em autotools} project is not very
complicated.

\section{Going further}

Run \code{autoscan}, read the generated \code{configure.scan} and
compare it to your \code{configure.ac}. What are the differences?

Run \code{make dist}, and look at the tarball that is generated. Your
project is ready to be released!

Now, run \code{git add} on \code{configure.ac}, \code{Makefile.am} and
\code{hello.c}, and do a new commit: \code{git commit -s -m "Add a
  real program"}. If you run \code{git status}, you can see that
there are really a lot of files generated by {\em autotols}, so add a
\code{.gitignore} file to tell Git to simply ignore them. This file
should contain something like:

\begin{verbatim}
.deps/
Makefile
Makefile.in
aclocal.m4
autom4te.cache/
compile
config.log
config.status
configure
depcomp
hello
hello.o
install-sh
missing
\end{verbatim}

The files \code{configure.scan} and \code{autoscan.log} can simply be
removed, they would only get re-created if we run \code{autoscan}
again.

Commit your \code{.gitignore} file

\begin{verbatim}
git add .gitignore
git commit -s -m ``Add gitignore file''
\end{verbatim}

Now at any time you can do \code{git clean -xdf} to ask Git to remove
all the files that are not under version control. This allows to
easily get rid of all the files generated by the {\em autotools} and
see more clearly what's part of your project.

