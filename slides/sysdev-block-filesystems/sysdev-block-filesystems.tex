\section{Block filesystems}

\subsection{Block devices}

\begin{frame}
  \frametitle{Block vs. flash}
  \begin{itemize}
  \item Storage devices are classified in two main types: {\bf block
      devices} and {\bf flash devices}
    \begin{itemize}
    \item They are handled by different subsystems and different
      filesystems
    \end{itemize}
  \item {\bf Block devices} can be read and written to on a per-block
    basis, in random order, without erasing.
    \begin{itemize}
    \item Hard disks, floppy disks, RAM disks
    \item USB keys, SSD, Compact Flash, SD card, eMMC: these are based
      on flash storage, but have an integrated controller that
      emulates a block device, managing the flash in a transparent
      way.
    \end{itemize}
  \item {\bf Raw flash devices} are driven by a controller on the
      SoC. They can be read, but writing requires erasing, and often occurs
      on a larger size than the “block” size.
    \begin{itemize}
    \item NOR flash, NAND flash
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Block device list}
  \begin{itemize}
  \item The list of all block devices available in the system can be
    found in \code{/proc/partitions}\\
\begin{verbatim}
$ cat /proc/partitions
major minor #blocks name

 179        0    3866624 mmcblk0
 179        1      73712 mmcblk0p1
 179        2    3792896 mmcblk0p2
   8        0  976762584 sda
   8        1    1060258 sda1
   8        2  975699742 sda2
\end{verbatim}
  \item And also in \code{/sys/block/}
  \end{itemize}
\end{frame}

\begin{frame}{Partitioning}
  \begin{itemize}
  \item Block devices can be partitioned to store different parts of a
    system
  \item The partition table is stored inside the device itself, and is
    read and analyzed automatically by the Linux kernel
    \begin{itemize}
    \item \code{mmcblk0} is the entire device
    \item \code{mmcblk0p2} is the second partition of \code{mmcblk0}
    \end{itemize}
  \item Two partition table formats:
    \begin{itemize}
    \item {\em MBR}, the legacy format
    \item {\em GPT}, the new format, not yet used everywhere, but
      becoming more and more common
    \end{itemize}
  \item Numerous tools to create and modify the partitions on a block
    device: \code{fdisk}, \code{cfdisk}, \code{sfdisk}, \code{parted},
    etc.
  \end{itemize}
\end{frame}

\begin{frame}{Transfering data to a block device}
  \begin{itemize}
  \item It is often necessary to transfer data to or from a block
    device in a {\em raw} way
    \begin{itemize}
    \item Especially to write a {\em filesystem image} to a block
      device
    \end{itemize}
  \item This directly writes to the block device itself, bypassing any
    filesystem layer.
  \item The block devices in \code{/dev/} allow such {\em raw} access
  \item \code{dd} is the tool of choice for such transfers:
    \begin{itemize}
    \item \code{dd if=/dev/mmcblk0p1 of=testfile bs=1M count=16}\\
      Transfers 16 blocks of 1 MB from \code{/dev/mmcblk0p1} to
      \code{testfile}
    \item \code{dd if=testfile of=/dev/sda2 bs=1M seek=4}\\
      Transfers the complete contents of \code{testfile} to
      \code{/dev/sda2}, by blocks of 1 MB, but starting at offset 4 MB
      in \code{/dev/sda2}
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Available filesystems}

\begin{frame}{Standard Linux filesystem format: ext2, ext3, ext4}
  \begin{itemize}
  \item The standard filesystem used on Linux systems is the series of
    \code{ext{2,3,4}} filesystems
    \begin{itemize}
    \item \code{ext2}
    \item \code{ext3}, brought {\em journaling} compared to \code{ext2}
    \item \code{ext4}, mainly brought performance improvements and
      support for even larger filesystems
    \end{itemize}
  \item \code{ext4} is now the default filesystem used on most Linux
    distributions
  \item It supports all features Linux needs from a filesystem:
    permissions, ownership, device files, symbolic links, etc.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Journaled filesystems}
  \begin{columns}
    \column{0.6\textwidth}
    \begin{itemize}
    \item Designed to stay in a coherent state even after system
      crashes or a sudden poweroff
    \item Writes are first described in the journal before being
      committed to files (can be all writes, or only metadata writes
      depending on the configuration)
    \item Allows to skip a full disk check at boot time after an
      unclean shutdown
    \end{itemize}
    \column{0.4\textwidth}
    \includegraphics[width=\textwidth]{slides/sysdev-block-filesystems/journal.pdf}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{Filesystem recovery after crashes}
  \begin{columns}
    \column{0.4\textwidth}
    \includegraphics[width=\textwidth]{slides/sysdev-block-filesystems/journal-recovery.pdf}
    \column{0.6\textwidth}
    \begin{itemize}
    \item Thanks to the journal, the recovery at boot time is quick,
      since the operations in progress at the moment of the unclean
      shutdown are clearly identified
    \item Does not mean that the latest writes made it to the storage:
      this depends on syncing the changes to the filesystem.
    \end{itemize}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{Other Linux/Unix filesystems}
  \begin{itemize}
  \item \code{btrfs}, intended to become the next standard filesystem
    for Linux. Integrates numerous features: data checksuming,
    integrated volume management, snapshots, etc.
  \item \code{XFS}, high-performance filesystem inherited from SGI
    IRIX, still actively developed.
  \item \code{JFS}, inherited from IBM AIX. No longer actively
    developed, provided mainly for compatibility.
  \item \code{reiserFS}, used to be a popular filesystem, but its
    latest version \code{Reiser4} was never merged upstream.
  \end{itemize}
  All those filesystems provide the necessary functionalities for
  Linux systems: symbolic links, permissions, ownership, device files,
  etc.
\end{frame}

\begin{frame}
  \frametitle{F2FS: filesystem for flash-based storage}
  \url{http://en.wikipedia.org/wiki/F2FS}
  \begin{itemize}
  \item Filesystem that takes into account the characteristics of
    flash-based storage: eMMC, SD cards, SSD, etc.
  \item Developed and contributed by Samsung
  \item Available in the mainline Linux kernel
  \item For optimal results, need a number of details about the
    storage internal behavior which may not easy to get
  \item Benchmarks: best performer on flash devices most of the time: \\
        See \url{http://lwn.net/Articles/520003/}
  \item Technical details: \url{http://lwn.net/Articles/518988/}
  \item Not as widely used as \code{ext3,4}, even on flash-based
    storage.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Squashfs: read-only filesystem}
  \begin{itemize}
  \item Read-only, compressed filesystem for block devices. Fine for
    parts of a filesystem which can be read-only (kernel, binaries...)
  \item Great compression rate, which generally brings improved read
    performance
  \item Used in most live CDs and live USB distributions
  \item Supports several compression algorithm (LZO, XZ, etc.)
  \item Benchmarks: roughly 3 times smaller than ext3, and 2-4 times
    faster (\url{http://elinux.org/Squash_Fs_Comparisons})
  \item Details: \url{http://squashfs.sourceforge.net/}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Compatibility filesystems}
  Linux also supports several other filesystem formats, mainly to be
  interopable with other operating systems:
  \begin{itemize}
  \item \code{vfat} for compatibility with the FAT filesystem used in
    the Windows world and on numerous removable devices
    \begin{itemize}
    \item This filesystem does {\em not} support features like
      permissions, ownership, symbolic links, etc. Cannot be used for
      a Linux root filesystem.
    \end{itemize}
  \item \code{ntfs} for compatibility with the NTFS filesystem used on
    Windows
  \item \code{hfs} for compatibility with the HFS filesystem used on
    Mac OS
  \item \code{iso9660}, the filesystem format used on CD-ROMs,
    obviously a read-only filesystem
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{tmpfs: filesystem in RAM}
  \begin{itemize}
  \item Not a block filesystem of course!
  \item Perfect to store temporary data in RAM: system log files,
    connection data, temporary files...
  \item More space-efficient than ramdisks: files are directly in the
    file cache, grows and shrinks to accommodate stored files
  \item How to use: choose a name to distinguish the various tmpfs
    instances you could have. Examples:\\
    \code{mount -t tmpfs varrun /var/run}\\
    \code{mount -t tmpfs udev /dev}
  \item  See \kerneldoc{filesystems/tmpfs.txt} in kernel sources.
  \end{itemize}
\end{frame}

\subsection{Using block filesystems}

\begin{frame}
  \frametitle{Creating ext2/ext3/ext4 filesystems}
  \begin{itemize}
  \item To create an empty ext2/ext3/ext4 filesystem on a block device or
    inside an already-existing image file
    \begin{itemize}
    \item \code{mkfs.ext2 /dev/hda3}
    \item \code{mkfs.ext3 /dev/sda2}
    \item \code{mkfs.ext4 /dev/sda3}
    \item \code{mkfs.ext2 disk.img}
    \end{itemize}
  \item To create a filesystem image from a directory containing all
    your files and directories
    \begin{itemize}
    \item Use the \code{genext2fs} tool, from the package of the same name
    \item \code{genext2fs -d rootfs/ rootfs.img}
    \item Your image is then ready to be transferred to your block
      device
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Mounting filesystem images}
  \begin{itemize}
  \item Once a filesystem image has been created, one can access and
    modifies its contents from the development workstation, using the
    {\bf loop} mechanism
  \item Example:\\
    \code{genext2fs -d rootfs/ rootfs.img}\\
    \code{mkdir /tmp/tst}\\
    \code{mount -t ext2 -o loop rootfs.img /tmp/tst}
  \item In the \code{/tmp/tst} directory, one can access and modify
    the contents of the \code{rootfs.img} file.
  \item This is possible thanks to \code{loop}, which is a kernel
    driver that emulates a block device with the contents of a file.
  \item Do not forget to run \code{umount} before using the filesystem
    image!
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Creating squashfs filesystems}
  \begin{itemize}
  \item Need to install the \code{squashfs-tools} package
  \item Can only create an image: creating an empty {\em squashfs}
    filesystem would be useless, since it's read-only.
  \item To create a {\em squashfs} image:
    \begin{itemize}
    \item \code{mksquashfs rootfs/ rootfs.sqfs -noappend}
    \item \code{-noappend}: re-create the image from scratch rather
      than appending to it
    \end{itemize}
  \item Mounting a squashfs filesystem:
    \begin{itemize}
    \item \code{mount -t squashfs /dev/<device> /mnt}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Mixing read-only and read-write filesystems}
  \begin{columns}
    \column{0.7\textwidth}
    Good idea to split your block storage into:
    \begin{itemize}
    \item A compressed read-only partition (\code{Squashfs})\\
      Typically used for the root filesystem (binaries, kernel...).\\
      Compression saves space. Read-only access protects your system
      from mistakes and data corruption.
    \item A read-write partition with a journaled filesystem (like \code{ext3})\\
      Used to store user or configuration data.\\
      Guarantees filesystem integrity after power off or crashes.
    \item Ram storage for temporary files (\code{tmpfs})
    \end{itemize}
    \column{0.3\textwidth}
    \includegraphics[width=\textwidth]{slides/sysdev-block-filesystems/mixing-filesystems.pdf}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{Issues with flash-based block storage}
  \begin{itemize}
  \item Flash storage made available only through a block interface.
  \item Hence, no way to access a low level flash interface
    and use the Linux filesystems doing wear leveling.
  \item No details about the layer (Flash Translation Layer) they
    use. Details are kept as trade secrets, and may hide poor
    implementations.
  \item Not knowing about the wear leveling algorithm, it is highly
    recommended to limit the number of writes to these devices.
  \end{itemize}
\end{frame}

\setuplabframe
{Block filesystems}
{
  \begin{itemize}
  \item Creating partitions on your block storage
  \item Booting your system with a mix of filesystems: SquashFS for
    the root filesystem (including applications), ext3 for
    configuration and user data, and tmpfs for
    temporary system files.
  \end{itemize}
}
