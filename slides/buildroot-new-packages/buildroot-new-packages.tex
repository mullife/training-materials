\setbeamerfont{block title}{size=\scriptsize}

\section{Integrating new packages in Buildroot}

\begin{frame}{Why adding new packages in Buildroot?}
  \begin{itemize}
  \item A {\em package} in Buildroot-speak is the {\bf set of
      meta-information needed to automate the build process} of a
    certain component of a system.
  \item Can be used for open-source, third party proprietary
    components, or in-house components.
  \item Can be used for user space components (libraries and
    applications) but also for firmware, kernel drivers, bootloaders,
    etc.
  \item Do not confuse with the notion of {\em binary package} in a
    regular Linux distribution.
  \end{itemize}
\end{frame}

\begin{frame}{Basic elements of a Buildroot package}
  \begin{itemize}
  \item A directory, \code{package/foo}
  \item A \code{Config.in} file, written in {\em kconfig} language,
    describing the configuration options for the package.
  \item A \code{<pkg>.mk} file, written in {\em make}, describing where to
    fetch the source, how to build and install it, etc.
  \item An optional \code{<pkg>.hash} file, providing hashes to check
    the integrity of the downloaded tarballs.
  \item Optionally, \code{.patch} files, that are applied on the
    package source code before building.
  \item Optionally, any additional file that might be useful for the
    package: init script, example configuration file, etc.
  \end{itemize}
\end{frame}

\subsection{{\tt Config.in} file}

\begin{frame}[fragile]{\code{package/<pkg>/Config.in}: basics}
  \begin{itemize}
  \item Describes the configuration options for the package.
  \item Written in the {\em kconfig} language.
  \item One option is mandatory to enable/disable the package, it {\bf
      must} be named \code{BR2_PACKAGE_<PACKAGE>}.
    \begin{block}{}
      \scriptsize
\begin{verbatim}
config BR2_PACKAGE_STRACE
        bool "strace"
        help
          A useful diagnostic, instructional, and debugging tool.
          Allows you to track what system calls a program makes
          while it is running.

          http://sourceforge.net/projects/strace/
\end{verbatim}
    \end{block}
  \item The main package option is a \code{bool} with the package name
    as the prompt. Will be visible in \code{menuconfig}.
  \item The help text give a quick description, and the homepage of
    the project.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{\code{package/<pkg>/Config.in}: inclusion}
  \begin{itemize}
  \item The hierarchy of configuration options visible in
    \code{menuconfig} is built by reading the top-level
    \code{Config.in} file and the other \code{Config.in} file it
    includes.
  \item All \code{package/<pkg>/Config.in} files are included from
    \code{package/Config.in}.
  \item The location of a package in one of the package sub-menu is
    decided in this file.
  \end{itemize}
  \begin{block}{package/Config.in}
    \tiny
\begin{verbatim}
menu "Target packages"
menu "Audio and video applications"
        source "package/alsa-utils/Config.in"
        ...
endmenu
...
menu "Libraries"
menu "Audio/Sound"
        source "package/alsa-lib/Config.in"
        ...
endmenu
...
\end{verbatim}
  \end{block}
\end{frame}

\begin{frame}{\code{package/<pkg>/Config.in}: dependencies}
  \begin{itemize}
  \item {\em kconfig} allows to express dependencies using
    \code{select} or \code{depends on} statements
    \begin{itemize}
    \item \code{select} is an automatic dependency: if option {\em A}
      \code{select} option {\em B}, as soon as {\em A} is enabled,
      {\em B} will be enabled, and cannot be unselected.
    \item \code{depends on} is a user-assisted dependency: if option
      {\em A} \code{depends on} option {\em B}, {\em A} will only be
      visible when {\em B} is enabled.
    \end{itemize}
  \item Buildroot uses them as follows:
    \begin{itemize}
    \item \code{depends on} for architecture, toolchain feature, or
      {\em big} feature dependencies. E.g: package only available on
      x86, or only if wide char support is enabled, or depends on
      Python.
    \item \code{select} for enabling the necessary other packages
      needed to build the current package (libraries, etc.)
    \end{itemize}
  \item Such dependencies only ensure consistency at the configuration
    level. They {\bf do not guarantee build ordering}!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{\code{package/<pkg>/Config.in}: dependency example}

  \begin{columns}
    \column{0.6\textwidth}
    \begin{block}{btrfs-progs package}
      \tiny
\begin{verbatim}
config BR2_PACKAGE_BTRFS_PROGS
        bool "btrfs-progs"
        depends on BR2_USE_WCHAR # util-linux
        depends on BR2_USE_MMU # util-linux
        depends on BR2_TOOLCHAIN_HAS_THREADS
        select BR2_PACKAGE_ACL
        select BR2_PACKAGE_ATTR
        select BR2_PACKAGE_E2FSPROGS
        select BR2_PACKAGE_LZO
        select BR2_PACKAGE_UTIL_LINUX
        select BR2_PACKAGE_UTIL_LINUX_LIBBLKID
        select BR2_PACKAGE_UTIL_LINUX_LIBUUID
        select BR2_PACKAGE_ZLIB
        help
          Btrfs filesystem utilities

          https://btrfs.wiki.kernel.org/in...

comment "btrfs-progs needs a toolchain w/ wchar, threads"
        depends on BR2_USE_MMU
        depends on !BR2_USE_WCHAR || \
               !BR2_TOOLCHAIN_HAS_THREADS
\end{verbatim}
  \end{block}
    \column{0.4\textwidth}
    {\scriptsize
    \begin{itemize}
    \item \code{depends on BR2_USE_MMU}, because the package uses
      \code{fork()}. Note that there is no comment displayed about this
      dependency, because it's a limitation of the architecture.
    \item \code{depends on BR2_USE_WCHAR} and \code{depends on
        BR2_TOOLCHAIN_HAS_THREADS}, because the package requires
      wide-char and thread support from the toolchain. There is an
      associated comment, because such support can be added to the
      toolchain.
    \item Multiple \code{select BR2_PACKAGE_*}, because the package
      needs numerous libraries.
    \end{itemize}}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Dependency propagation}

  \begin{itemize}
  \item A limitation of {\em kconfig} is that it doesn't propagate
    \code{depends on} dependencies accross \code{select} dependencies.
  \item Scenario: if package {\em A} has a \code{depends on FOO}, and
    package {\em B} has a \code{select A}, then package {\em B} must
    replicate the \code{depends on FOO}.
  \end{itemize}

  \begin{columns}
    \column{0.5\textwidth}
    \begin{block}{libglib2 package}
      \tiny
\begin{verbatim}
config BR2_PACKAGE_LIBGLIB2
        bool "libglib2"
        select BR2_PACKAGE_GETTEXT if ...
        select BR2_PACKAGE_LIBICONV if ...
        select BR2_PACKAGE_LIBFFI
        select BR2_PACKAGE_ZLIB
        [...]
        depends on BR2_USE_WCHAR # gettext
        depends on BR2_TOOLCHAIN_HAS_THREADS
        depends on BR2_USE_MMU # fork()
[...]
\end{verbatim}
    \end{block}
    \column{0.5\textwidth}
    \begin{block}{neard package}
      \tiny
\begin{verbatim}
config BR2_PACKAGE_NEARD
        bool "neard"
        depends on BR2_USE_WCHAR # libglib2
        # libnl, dbus, libglib2
        depends on BR2_TOOLCHAIN_HAS_THREADS
        depends on BR2_USE_MMU # dbus, libglib2
        select BR2_PACKAGE_DBUS
        select BR2_PACKAGE_LIBGLIB2
        select BR2_PACKAGE_LIBNL
[...]
\end{verbatim}
    \end{block}
  \end{columns}
\end{frame}

\begin{frame}{\code{Config.in.host} for host packages?}
  \begin{itemize}
  \item Most of the packages in Buildroot are {\em target} packages,
    i.e. they are cross-compiled for the target architecture, and meant
    to be run on the target platform.
  \item Some packages have a {\em host} variant, built to be executed
    on the build machine. Such packages are needed for the build
    process of other packages.
  \item The majority of {\em host} packages are not visible in
    \code{menuconfig}: they are just dependencies of other packages,
    the user doesn't really need to know about them.
  \item A few of them are potentially directly useful to the user
    (flashing tools, etc.), and can be shown in the {\em Host
      utilities} section of \code{menuconfig}.
  \item In this case, the configuration option is in a
    \code{Config.in.host} file, included from
    \code{package/Config.in.host}, and the option must be named
    \code{BR2_PACKAGE_HOST_<PACKAGE>}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{\code{Config.in.host} example}
  \begin{block}{package/Config.in.host}
    \tiny
\begin{verbatim}
menu "Host utilities"

        source "package/genimage/Config.in.host"
        source "package/lpc3250loader/Config.in.host"
        source "package/openocd/Config.in.host"
        source "package/qemu/Config.in.host"

endmenu
\end{verbatim}
  \end{block}

  \begin{block}{package/openocd/Config.in.host}
    \tiny
\begin{verbatim}
config BR2_PACKAGE_HOST_OPENOCD
        bool "host openocd"
        help
          OpenOCD - Open On-Chip Debugger

          http://openocd.org
\end{verbatim}
  \end{block}
\end{frame}

\begin{frame}[fragile]{\code{Config.in} sub-options}
  \begin{columns}
    \column{0.4\textwidth}
    \begin{itemize}
    \item Additional sub-options can be defined to further configure
      the package, to enable or disable extra features.
    \item The value of such options can then be fetched from the package
      \code{.mk} file to adjust the build accordingly.
    \item Run-time configuration does not belong to \code{Config.in}.
    \end{itemize}
    \column{0.6\textwidth}
    \begin{block}{package/pppd/Config.in}
      \tiny
\begin{verbatim}
config BR2_PACKAGE_PPPD
        bool "pppd"
        depends on !BR2_STATIC_LIBS
        depends on BR2_USE_MMU
        ...

if BR2_PACKAGE_PPPD

config BR2_PACKAGE_PPPD_FILTER
        bool "filtering"
        select BR2_PACKAGE_LIBPCAP
        help
          Packet filtering abilities for pppd. If enabled,
          the pppd active-filter and pass-filter options
          are available.

config BR2_PACKAGE_PPPD_RADIUS
        bool "radius"
        help
          Install RADIUS support for pppd

endif
\end{verbatim}
    \end{block}
  \end{columns}
\end{frame}

\subsection{Package infrastructures}

\begin{frame}{Package infrastructures: what is it?}
  \begin{itemize}
  \item Each software component to be built by Buildroot comes with
    its own {\em build system}.
  \item Buildroot does not re-invent the build system of each
    component, it simply uses it.
  \item Numerous build systems available: hand-written Makefiles or
    shell scripts, {\em autotools}, {\em CMake} and also some specific
    to languages: Python, Perl, Lua, Erlang, etc.
  \item In order to avoid duplicating code, Buildroot has {\em package
      infrastructures} for well-known build systems.
  \item And a generic package infrastructure for software components
    with non-standard build systems.
  \end{itemize}
\end{frame}

\begin{frame}{Package infrastructures}
  \begin{center}
    \includegraphics[width=\textwidth]{slides/buildroot-new-packages/package-infrastructures.pdf}
  \end{center}
\end{frame}

\begin{frame}{\code{generic-package} infrastructure}
  \begin{itemize}
  \item To be used for software components having non-standard build
    systems.
  \item Implements a default behavior for the downloading, extracting
    and patching steps of the package build process.
  \item Implements init script installation, legal information
    collection, etc.
  \item Leaves to the package developer the responsibility of
    describing what should be done for the configuration, building and
    installation steps.
  \end{itemize}
\end{frame}

\begin{frame}{\code{generic-package}: steps}
  \begin{center}
    \includegraphics[width=\textwidth]{slides/buildroot-new-packages/generic-package.pdf}
  \end{center}
\end{frame}

\begin{frame}{Other package infrastructures}
  \begin{itemize}
  \item The other package infrastructures are meant to be used when
    the software component uses a well-known build system.
  \item They {\em inherit} all the behavior of the
    \code{generic-package} infrastructure: downloading, extracting,
    patching, etc.
  \item And in addition to that, they typically implement a default
    behavior for the configuration, compilation and installation
    steps.
  \item For example, \code{autotools-package} will implement the
    configuration step as a call to the \code{./configure} script with
    the right arguments.
  \item \code{pkg-kconfig} is an exception, it only provides some
    helpers for packages using Kconfig, but does not implement the
    configure, build and installation steps.
  \end{itemize}
\end{frame}

\subsection{{\tt .mk} file for {\tt generic-package}}

\begin{frame}[fragile]{The \code{<pkg>.mk} file}
  \begin{itemize}
  \item The \code{.mk} file of a package does not look like a normal
    Makefile.
  \item It is a succession of variable definitions, which must be
    prefixed by the uppercase package name.
    \begin{itemize}
    \item \code{FOOBAR_SITE = http://foobar.com/downloads/}
    \item
\begin{minted}{make}
define FOOBAR_BUILD_CMDS
       $(MAKE) -C $(@D)
endef
\end{minted}
    \end{itemize}
  \item And ends with a call to the desired package infrastructure
    macro.
    \begin{itemize}
    \item \code{$(eval $(generic-package))}
    \item \code{$(eval $(autotools-package))}
    \item \code{$(eval $(host-autotools-package))}
    \end{itemize}
  \item The variables tell the package infrastructure what to do for
    this specific package.
  \end{itemize}
\end{frame}

\begin{frame}{Naming conventions}

  \begin{itemize}
  \item The Buildroot package infrastructures make a number of
    assumption on variables and files naming.
  \item The following {\bf must} match to allow the package
    infrastructure to work for a given package:
    \begin{itemize}
    \item The directory where the package description is located {\bf
        must} be \code{package/<pkg>/}, where \code{<pkg>} is the
      lowercase name of the package.
    \item The \code{Config.in} option enabling the package {\bf must}
      be named \code{BR2_PACKAGE_<PKG>}, where \code{<PKG>} is the
      uppercase name of the package.
    \item The variables in the \code{.mk} file {\bf must} be prefixed
      with \code{<PKG>_}, where \code{<PKG>} is the uppercase name of
      the package.
    \end{itemize}
  \item Note: a \code{-} in the lower-case package name is translated
    to \code{_} in the upper-case package name.
  \end{itemize}
\end{frame}

\begin{frame}{Naming conventions: global namespace}
  \begin{itemize}
  \item The package infrastructure expects all variables it uses to be
    prefixed by the uppercase package name.
  \item If your package needs to define additional private variables
    not used by the package infrastructure, they {\bf should} also be
    prefixed by the {\bf uppercase package name}.
  \item The {\bf namespace of variables is global} in Buildroot!
    \begin{itemize}
    \item If two packages created a variable named \code{BUILD_TYPE},
      it will silently conflict.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Behind the scenes}
  \begin{itemize}
  \item Behind the scenes, \code{$(eval $(generic-package))}:
    \begin{itemize}
    \item is a {\em make} macro that is expanded
    \item infers the name of the current package by looking at the
      directory name: \code{package/<pkg>/<pkg>.mk}: \code{<pkg>} is
      the package name
    \item will use all the variables prefixed by \code{<PKG>_}
    \item and expand to a set of {\em make} rules and variable
      definitions that describe what should be done for each step of
      the package build process
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{{\tt .mk} file: accessing the configuration}

  \begin{itemize}
  \item The Buildroot \code{.config} file is a succession of lines
    \code{name = value}
    \begin{itemize}
    \item This file is valid {\em make} syntax!
    \end{itemize}
  \item The main Buildroot \code{Makefile} simply includes it, which
    turns every Buildroot configuration option into a {\em make}
    variable.
  \item From a package \code{.mk} file, one can directly use such
    variables:
    \begin{block}{}
    \begin{minted}[fontsize=\tiny]{make}
ifeq ($(BR2_PACKAGE_LIBCURL),y)
...
endif

FOO_DEPENDENCIES += $(if $(BR2_PACKAGE_TIFF),tiff)
\end{minted}
\end{block}

\item Hint: use the {\em make} \code{qstrip} function to remove double
  quotes on string options:
\begin{block}{}
  \begin{minted}[fontsize=\tiny]{make}
NODEJS_MODULES_LIST = $(call qstrip,$(BR2_PACKAGE_NODEJS_MODULES_ADDITIONAL))
  \end{minted}
\end{block}
  \end{itemize}
\end{frame}

\begin{frame}{Download related variables}
  \begin{itemize}
  \item \code{<pkg>_SITE}, {\bf download location}
    \begin{itemize}
    \item HTTP(S) or FTP URL where a tarball can be found, or the address
      of a version control repository.
    \item \code{CAIRO_SITE = http://cairographics.org/releases}
    \item \code{FMC_SITE = git://git.freescale.com/ppc/sdk/fmc.git}
    \end{itemize}
  \item \code{<pkg>_VERSION}, {\bf version of the
    package}
  \begin{itemize}
    \item version of a tarball, or a commit, revision or tag for
      version control systems
    \item \code{CAIRO_VERSION = 1.14.2}
    \item \code{FMC_VERSION = fsl-sdk-v1.5-rc3}
    \end{itemize}
  \item \code{<pkg>_SOURCE}, {\bf file name} of the tarball
    \begin{itemize}
    \item The full URL of the downloaded tarball is
      \code{$(<pkg>_SITE)/$(<pkg>_SOURCE)}
    \item When not specified, defaults to
      \code{<pkg>-$(<pkg>_VERSION).tar.gz}
    \item \code{CAIRO_SOURCE = cairo-$(CAIRO_VERSION).tar.xz}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Available download methods}
  \begin{itemize}
  \item Buildroot can fetch the source code using different methods:
    \begin{itemize}
    \item \code{wget}, for FTP/HTTP downloads
    \item \code{scp}, to fetch the tarball using SSH/SCP
    \item \code{svn}, for Subversion
    \item \code{cvs}, for CVS
    \item \code{git}, for Git
    \item \code{hg}, for Mercurial
    \item \code{bzr}, for Bazaar
    \item \code{file}, for a local tarball
    \item \code{local}, for a local directory
    \end{itemize}
  \item In most cases, the fetching method is guessed by Buildroot
    using the \code{<pkg>_SITE} variable.
  \item Exceptions:
    \begin{itemize}
    \item Git, Subversion or Mercurial repositories accessed over
      HTTP or SSH.
    \item \code{file} and \code{local} methods
    \end{itemize}
  \item In such cases, use \code{<pkg>_SITE_METHOD} explicitly.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Download methods examples}

  \begin{itemize}
  \item Subversion repository accessed over HTTP:
    \begin{block}{}
      \begin{minted}{make}
CJSON_VERSION = 58
CJSON_SITE_METHOD = svn
CJSON_SITE = http://svn.code.sf.net/p/cjson/code
      \end{minted}
    \end{block}
  \item Source code available in a local directory:
    \begin{block}{}
      \begin{minted}{make}
MYAPP_SITE = $(TOPDIR)/../apps/myapp
MYAPP_SITE_METHOD = local
      \end{minted}
    \end{block}
    \begin{itemize}
    \item The "{\em download}" will consist in copying the source code
      from the designated directory to the Buildroot per-package build
      directory.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Downloading more elements}
  \begin{itemize}
  \item \code{<pkg>_PATCH}, a list of patches to download and apply
    before building the package. They are automatically applied by the
    package infrastructure.
  \item \code{<pkg>_EXTRA_DOWNLOADS}, a list of additional files to
    download together with the package source code. It is up to the
    package \code{.mk} file to do something with them.
  \item Two options:
    \begin{itemize}
    \item Just a file name: assumed to be relative to \code{<pkg>_SITE}.
    \item A full URL: downloaded over HTTP, FTP.
    \end{itemize}
  \item Examples:
    \begin{block}{sysvinit.mk}
      \begin{minted}[fontsize=\tiny]{make}
SYSVINIT_PATCH = sysvinit_$(SYSVINIT_VERSION)dsf-13.1+squeeze1.diff.gz
      \end{minted}
    \end{block}

    \begin{block}{perl.mk}
      \begin{minted}[fontsize=\tiny]{make}
PERL_CROSS_SITE = http://raw.github.com/arsv/perl-cross/releases
PERL_CROSS_SOURCE = perl-$(PERL_CROSS_BASE_VERSION)-cross-$(PERL_CROSS_VERSION).tar.gz
PERL_EXTRA_DOWNLOADS = $(PERL_CROSS_SITE)/$(PERL_CROSS_SOURCE)
      \end{minted}
    \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Hash file}

  \begin{itemize}

  \item In order to validate the integrity of downloaded files, and
    make sure the user uses the version which was tested by the
    Buildroot developers, {\em cryptographic hashes} are used

  \item Each package may contain a file named \code{<package>.hash},
    which gives the hashes of the files downloaded by the package.

  \item When present, the hashes for {\bf all} files downloaded by the
    package must be documented.

  \item The syntax of the file is:
\begin{block}{}
{\tiny
\begin{verbatim}
<hashtype> <hash> <file>
\end{verbatim}
}
\end{block}

  \item Example:

\begin{block}{}
{\tiny
\begin{verbatim}
# Locally computed
sha256 2ee80bd0634a61a...3530396cccc09 unionfs-1.0.tar.gz
sha256 c8526f80448f344...03bcd713d9de2 0001-include-asm-ioctl.h-for-_IOC_SIZE.patch
\end{verbatim}
}
\end{block}

  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Describing dependencies}
  \begin{itemize}
  \item Dependencies expressed in \code{Config.in} do not enforce
    build order.
  \item The \code{<pkg>_DEPENDENCIES} variable is used to describe the
    dependencies of the current package.
  \item Packages listed in \code{<pkg>_DEPENDENCIES} are guaranteed to
    be built before the {\em configure} step of the current package
    starts.
  \item It can contain both target and host packages.
  \item It can be appended conditionally with additional dependencies.
  \end{itemize}

  \begin{block}{python.mk}
    \begin{minted}[fontsize=\scriptsize]{make}
PYTHON_DEPENDENCIES = host-python libffi

ifeq ($(BR2_PACKAGE_PYTHON_READLINE),y)
PYTHON_DEPENDENCIES += readline
endif
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}{Mandatory vs. optional dependencies}

  \begin{itemize}
  \item Very often, software components have some {\bf mandatory
      dependencies} and some {\bf optional dependencies}, only needed
    for optional features.
  \item Handling mandatory dependencies in Buildroot consists in:
    \begin{itemize}
    \item Using a \code{select} or \code{depends on} on the main
      package option in \code{Config.in}
    \item Adding the dependency in \code{<pkg>_DEPENDENCIES}
    \end{itemize}
  \item For optional dependencies, there are two possibilities:
    \begin{itemize}
    \item Handle it automatically: in the \code{.mk} file, if the
      optional dependency is available, use it.
    \item Handle it explicitly: add a package sub-option in the
      \code{Config.in} file.
    \end{itemize}
  \item {\em Automatic} handling is usually preferred as it reduces
    the number of \code{Config.in} options, but it makes the possible
    dependency less visible to the user.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Dependencies: {\tt ntp} example}

  \begin{itemize}
  \item Mandatory dependency: \code{libevent}
  \item Optional dependency handled automatically: \code{openssl}
  \end{itemize}

\begin{block}{package/ntp/Config.in}
{\scriptsize
\begin{verbatim}
config BR2_PACKAGE_NTP
        bool "ntp"
        select BR2_PACKAGE_LIBEVENT
[...]
\end{verbatim}}
\end{block}

\begin{block}{package/ntp/ntp.mk}
\begin{minted}[fontsize=\scriptsize]{make}
[...]
NTP_DEPENDENCIES = host-pkgconf libevent
[...]
ifeq ($(BR2_PACKAGE_OPENSSL),y)
NTP_CONF_OPTS += --with-crypto
NTP_DEPENDENCIES += openssl
else
NTP_CONF_OPTS += --without-crypto --disable-openssl-random
endif
[...]
\end{minted}
\end{block}

\end{frame}

\begin{frame}[fragile]{Dependencies: {\tt mpd} example (1/2)}

\begin{block}{package/mpd/Config.in}
{\scriptsize
\begin{verbatim}
menuconfig BR2_PACKAGE_MPD
        bool "mpd"
        depends on BR2_INSTALL_LIBSTDCPP
[...]
        select BR2_PACKAGE_BOOST
        select BR2_PACKAGE_LIBGLIB2
        select BR2_PACKAGE_LIBICONV if !BR2_ENABLE_LOCALE
[...]

config BR2_PACKAGE_MPD_FLAC
        bool "flac"
        select BR2_PACKAGE_FLAC
        help
          Enable flac input/streaming support.
          Select this if you want to play back FLAC files.

\end{verbatim}}
\end{block}

\end{frame}

\begin{frame}[fragile]{Dependencies: {\tt mpd} example (2/2)}

\begin{block}{package/mpd/mpd.mk}
\begin{minted}[fontsize=\scriptsize]{make}
MPD_DEPENDENCIES = host-pkgconf boost libglib2

[...]

ifeq ($(BR2_PACKAGE_MPD_FLAC),y)
MPD_DEPENDENCIES += flac
MPD_CONF_OPTS += --enable-flac
else
MPD_CONF_OPTS += --disable-flac
endif
\end{minted}
\end{block}

\end{frame}


\begin{frame}{Defining where to install (1)}
  \begin{itemize}
  \item Target packages can install files to different locations:
    \begin{itemize}
    \item To the {\em target} directory, \code{$(TARGET_DIR)}, which is
      what will be the target root filesystem.
    \item To the {\em staging} directory, \code{$(STAGING_DIR)}, which
      is the compiler {\em sysroot}
    \item To the {\em images} directory, \code{$(BINARIES_DIR)}, which
      is where final images are located.
    \end{itemize}
  \item There are three corresponding variables, to define whether or
    not the package will install something to one of these locations:
    \begin{itemize}
    \item \code{<pkg>_INSTALL_TARGET}, defaults to \code{YES}. If
      \code{YES}, then \code{<pkg>_INSTALL_TARGET_CMDS} will be
      called.
    \item \code{<pkg>_INSTALL_STAGING}, defaults to \code{NO}. If
      \code{YES}, then \code{<pkg>_INSTALL_STAGING_CMDS} will be
      called.
    \item \code{<pkg>_INSTALL_IMAGES}, defaults to \code{NO}. If
      \code{YES}, then \code{<pkg>_INSTALL_IMAGES_CMDS} will be
      called.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Defining where to install (2)}

  \begin{itemize}
  \item A package for an application:
    \begin{itemize}
    \item installs to \code{$(TARGET_DIR)} only
    \item \code{<pkg>_INSTALL_TARGET} defaults to \code{YES}, so there
      is nothing to do
    \end{itemize}
  \item A package for a shared library:
    \begin{itemize}
    \item installs to both \code{$(TARGET_DIR)} and \code{$(STAGING_DIR)}
    \item must set \code{<pkg>_INSTALL_STAGING = YES}
    \end{itemize}
  \item A package for a pure header-based library, or a static-only
    library:
    \begin{itemize}
    \item installs only to \code{$(STAGING_DIR)}
    \item must set \code{<pkg>_INSTALL_TARGET = NO} and
    \code{<pkg>_INSTALL_STAGING = YES}
  \end{itemize}
  \item A package installing a bootloader or kernel image:
    \begin{itemize}
    \item installs to \code{$(BINARIES_DIR)}
    \item must set \code{<pkg>_INSTALL_IMAGES = YES}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Defining where to install (3)}
  \begin{block}{libyaml.mk}
    \begin{minted}[fontsize=\footnotesize]{make}
LIBYAML_INSTALL_STAGING = YES
    \end{minted}
  \end{block}

  \begin{block}{eigen.mk}
    \begin{minted}[fontsize=\footnotesize]{make}
EIGEN_INSTALL_STAGING = YES
EIGEN_INSTALL_TARGET = NO
    \end{minted}
  \end{block}

  \begin{block}{linux.mk}
    \begin{minted}[fontsize=\footnotesize]{make}
LINUX_INSTALL_IMAGES = YES
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}{Describing actions for \code{generic-package}}
  \begin{itemize}
  \item In a package using \code{generic-package}, only the download,
    extract and patch steps are implemented by the package
    infrastructure.
  \item The other steps should be described by the package \code{.mk}
    file:
    \begin{itemize}
    \item \code{<pkg>_CONFIGURE_CMDS}, always called
    \item \code{<pkg>_BUILD_CMDS}, always called
    \item \code{<pkg>_INSTALL_TARGET_CMDS}, called when
      \code{<pkg>_INSTALL_TARGET = YES}, for target packages
    \item \code{<pkg>_INSTALL_STAGING_CMDS}, called when
      \code{<pkg>_INSTALL_STAGING = YES}, for target packages
    \item \code{<pkg>_INSTALL_IMAGES_CMDS}, called when
      \code{<pkg>_INSTALL_IMAGES = YES}, for target packages
    \item \code{<pkg>_INSTALL_CMDS}, always called for host packages
    \end{itemize}
  \item Packages are free to not implement any of these variables:
    they are all optional.
  \end{itemize}
\end{frame}

\begin{frame}{Describing actions: useful variables}
  Inside an action block, the following variables are often useful:
  \begin{itemize}
  \item \code{$(@D)} is the source directory of the package
  \item \code{$(MAKE)} to call \code{make}
  \item \code{$(MAKE1)} when the package doesn't build properly in
    parallel mode
  \item \code{$(TARGET_MAKE_ENV)} and \code{$(HOST_MAKE_ENV)}, to pass
    in the \code{$(MAKE)} environment to ensure the \code{PATH} is
    correct
  \item \code{$(TARGET_CONFIGURE_OPTS)} and
    \code{$(HOST_CONFIGURE_OPTS)} to pass \code{CC}, \code{LD},
    \code{CFLAGS}, etc.
  \item \code{$(TARGET_DIR)}, \code{$(STAGING_DIR)},
    \code{$(BINARIES_DIR)} and \code{$(HOST_DIR)}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Describing actions: example (1)}
  \begin{block}{eeprog.mk}
    \begin{minted}[fontsize=\scriptsize]{make}
EEPROG_VERSION = 0.7.6
EEPROG_SITE = http://www.codesink.org/download
EEPROG_LICENSE = GPLv2+
EEPROG_LICENSE_FILES = eeprog.c

define EEPROG_BUILD_CMDS
        $(MAKE) $(TARGET_CONFIGURE_OPTS) -C $(@D)
endef

define EEPROG_INSTALL_TARGET_CMDS
        $(INSTALL) -m 0755 -D $(@D)/eeprog $(TARGET_DIR)/usr/bin/eeprog
endef

$(eval $(generic-package))
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Describing actions: example (2)}
  \begin{block}{zlib.mk}
    \begin{minted}[fontsize=\tiny]{make}
ZLIB_VERSION = 1.2.8
ZLIB_SOURCE = zlib-$(ZLIB_VERSION).tar.xz
ZLIB_SITE = http://downloads.sourceforge.net/project/libpng/zlib/$(ZLIB_VERSION)
ZLIB_INSTALL_STAGING = YES

define ZLIB_CONFIGURE_CMDS
        (cd $(@D); rm -rf config.cache; \
                $(TARGET_CONFIGURE_ARGS) \
                $(TARGET_CONFIGURE_OPTS) \
                CFLAGS="$(TARGET_CFLAGS) $(ZLIB_PIC)" \
                ./configure \
                $(ZLIB_SHARED) \
                --prefix=/usr \
        )
endef

define ZLIB_BUILD_CMDS
        $(MAKE1) -C $(@D)
endef

define ZLIB_INSTALL_STAGING_CMDS
        $(MAKE1) -C $(@D) DESTDIR=$(STAGING_DIR) LDCONFIG=true install
endef

define ZLIB_INSTALL_TARGET_CMDS
        $(MAKE1) -C $(@D) DESTDIR=$(TARGET_DIR) LDCONFIG=true install
endef

$(eval $(generic-package))
    \end{minted}
  \end{block}
\end{frame}

\subsection{{\tt autotools-package} infrastructure}

\begin{frame}{The \code{autotools-package} infrastructure: basics}

  \begin{itemize}
  \item The \code{autotools-package} infrastructure inherits from
    \code{generic-package} and is specialized to handle {\em
      autotools} based packages.
  \item It provides a default implementation of:
    \begin{itemize}
    \item \code{<pkg>_CONFIGURE_CMDS}. Calls the \code{./configure}
      script with appropriate environment variables and arguments.
    \item \code{<pkg>_BUILD_CMDS}. Calls \code{make}.
    \item \code{<pkg>_INSTALL_TARGET_CMDS},
      \code{<pkg>_INSTALL_STAGING_CMDS} and
      \code{<pkg>_INSTALL_CMDS}. Call \code{make install} with the
      appropriate \code{DESTDIR}.
    \end{itemize}
  \item A normal {\em autotools} based package therefore does not need
    to describe any action: only metadata about the package.
  \end{itemize}
\end{frame}

\begin{frame}{The \code{autotools-package}: steps}
  \begin{center}
    \includegraphics[width=\textwidth]{slides/buildroot-new-packages/autotools-package.pdf}
  \end{center}
\end{frame}

\begin{frame}{The \code{autotools-package} infrastructure: variables}
  \begin{itemize}
  \item It provides additional variables that can be defined by the
    package:
    \begin{itemize}
    \item \code{<pkg>_CONF_ENV} to pass additional values in the
      environment of the \code{./configure} script.
    \item \code{<pkg>_CONF_OPTS} to pass additional options to the
      \code{./configure} script.
    \item \code{<pkg>_INSTALL_OPTS}, \code{<pkg>_INSTALL_STAGING_OPTS}
      and \code{<pkg>_INSTALL_TARGET_OPTS} to adjust the {\em make}
      target and options used for the installation.
    \item \code{<pkg>_AUTORECONF}. Defaults to \code{NO}, can be set
      to \code{YES} if regenerating \code{Makefile.in} files and
      \code{configure} script is needed. The infrastructure will
      automatically make sure {\em autoconf}, {\em automake}, {\em
        libtool} are built.
    \item \code{<pkg>_GETTEXTIZE}. Defaults to \code{NO}, can be set
      to \code{YES} to {\em gettextize} the package. Only makes sense
      if \code{<pkg>_AUTORECONF = YES}.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Canonical \code{autotools-package} example}
  \begin{block}{libyaml.mk}
    \begin{minted}[fontsize=\scriptsize]{make}
LIBYAML_VERSION = 0.1.6
LIBYAML_SOURCE = yaml-$(LIBYAML_VERSION).tar.gz
LIBYAML_SITE = http://pyyaml.org/download/libyaml
LIBYAML_INSTALL_STAGING = YES
LIBYAML_LICENSE = MIT
LIBYAML_LICENSE_FILES = LICENSE

$(eval $(autotools-package))
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]{More complicated \code{autotools-package} example}
  \begin{columns}
    \column{0.5\textwidth}
    \begin{block}{}
      \begin{minted}[fontsize=\tiny]{make}
POPPLER_VERSION = 0.32.0
POPPLER_SOURCE = poppler-$(POPPLER_VERSION).tar.xz
POPPLER_SITE = http://poppler.freedesktop.org
POPPLER_DEPENDENCIES = fontconfig
POPPLER_LICENSE = GPLv2+
POPPLER_LICENSE_FILES = COPYING
POPPLER_INSTALL_STAGING = YES
POPPLER_CONF_OPTS = \
   --with-font-configuration=fontconfig

ifeq ($(BR2_PACKAGE_LCMS2),y)
POPPLER_CONF_OPTS += --enable-cms=lcms2
POPPLER_DEPENDENCIES += lcms2
else
POPPLER_CONF_OPTS += --enable-cms=none
endif

ifeq ($(BR2_PACKAGE_TIFF),y)
POPPLER_CONF_OPTS += --enable-libtiff
POPPLER_DEPENDENCIES += tiff
else
POPPLER_CONF_OPTS += --disable-libtiff
endif

[...]
\end{minted}
\end{block}
\column{0.5\textwidth}
    \begin{block}{}
      \begin{minted}[fontsize=\tiny]{make}
[...]

ifeq ($(BR2_PACKAGE_POPPLER_QT),y)
POPPLER_DEPENDENCIES += qt
POPPLER_CONF_OPTS += --enable-poppler-qt4
else
POPPLER_CONF_OPTS += --disable-poppler-qt4
endif

ifeq ($(BR2_PACKAGE_OPENJPEG),y)
POPPLER_DEPENDENCIES += openjpeg
POPPLER_CONF_OPTS += \
   -enable-libopenjpeg=openjpeg1
else
POPPLER_CONF_OPTS += -enable-libopenjpeg=none
endif

$(eval $(autotools-package))
      \end{minted}
    \end{block}
  \end{columns}
\end{frame}

\subsection{{\tt python-package} infrastructure}

\begin{frame}{Python package infrastructure: basics}
  \begin{itemize}
  \item Modules for the Python language often use {\em distutils} or
    {\em setuptools} as their build/installation system.
  \item Buildroot provides a \code{python-package} infrastructure for
    such packages.
  \item Supports all the \code{generic-package} metadata information
    (source, site, license, etc.)
  \item Adds a mandatory variable \code{<pkg>_SETUP_TYPE}, which must
    be set to either \code{distutils} or \code{setuptools}
  \item And several optional variables to further adjust the build:
    \code{<pkg>_ENV}, \code{<pkg>_BUILD_OPTS},
    \code{<pkg>_INSTALL_TARGET_OPTS},
    \code{<pkg>_INSTALL_STAGING_OPTS}, \code{<pkg>_INSTALL_OPTS},
    \code{<pkg>_NEEDS_HOST_PYTHON}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Python package: simple example}

  \begin{block}{python-serial.mk}
    \begin{minted}[fontsize=\scriptsize]{make}
PYTHON_SERIAL_VERSION = 2.6
PYTHON_SERIAL_SOURCE = pyserial-$(PYTHON_SERIAL_VERSION).tar.gz
PYTHON_SERIAL_SITE = http://pypi.python.org/packages/source/p/pyserial
PYTHON_SERIAL_LICENSE = Python Software Foundation License
PYTHON_SERIAL_LICENSE_FILES = LICENSE.txt
PYTHON_SERIAL_SETUP_TYPE = distutils

$(eval $(python-package))
    \end{minted}
  \end{block}

\end{frame}

\begin{frame}[fragile]{Python package: more complicated example}
  \begin{block}{python-serial.mk}
    \begin{minted}[fontsize=\scriptsize]{make}
PYTHON_LXML_VERSION = 3.4.2
PYTHON_LXML_SITE = http://lxml.de/files
PYTHON_LXML_SOURCE = lxml-$(PYTHON_LXML_VERSION).tgz
[...]
PYTHON_LXML_SETUP_TYPE = setuptools
PYTHON_LXML_DEPENDENCIES = libxml2 libxslt zlib

PYTHON_LXML_BUILD_OPTS = \
        --with-xslt-config=$(STAGING_DIR)/usr/bin/xslt-config \
        --with-xml2-config=$(STAGING_DIR)/usr/bin/xml2-config

$(eval $(python-package))
    \end{minted}
  \end{block}
\end{frame}

\subsection{Target vs. host packages}

\begin{frame}{Host packages}

  \begin{itemize}
  \item As explained earlier, most packages in Buildroot are
    cross-compiled for the target. They are called {\bf target
      packages}.
  \item Some packages however may need to be built natively for the
    build machine, they are called {\bf host packages}. They can be
    needed for a variety of reasons:
    \begin{itemize}
    \item Needed as a tool to build other things for the
      target. Buildroot wants to limit the number of host utilities
      required to be installed on the build machine, and wants to ensure
      the proper version is used. So it builds some host utilities by
      itself.
    \item Needed as a tool to interact, debug, reflash, generate images,
      or other activities around the build itself.
    \item Version dependencies: building a Python interpreter for the
      target needs a Python interpreter of the same version on the
      host.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Target vs. host in the package infrastructure (1)}
  \begin{itemize}
  \item Each package infrastructure provides a \code{<foo>-package}
    macro and a \code{host-<foo>-package} macro.
  \item For a given package in \code{package/baz/baz.mk},
    \code{<foo>-package} will create a package named \code{baz} and
    \code{host-<foo>-package} will create a package named
    \code{host-baz}.
  \item \code{<foo>-package} will use the variables prefixed with
    \code{BAZ_}
  \item \code{host-<foo>-package} will use the variables prefixed with
    \code{HOST_BAZ_}
  \end{itemize}
\end{frame}

\begin{frame}{Target vs. host in the package infrastructure (2)}
  \begin{itemize}
  \item For many variables, when \code{HOST_BAZ_<var>} is not defined,
    the package infrastructure uses \code{BAZ_<var>} instead: source,
    site, version, license, etc.
    \begin{itemize}
    \item E.g. defining \code{<PKG>_SITE} once is sufficient.
    \end{itemize}
  \item But not for all variables, especially commands
    \begin{itemize}
    \item E.g. \code{HOST_<PKG>_BUILD_CMDS} is not inherited
      from \code{<PKG>_BUILD_CMDS}
    \end{itemize}
  \item \code{HOST_<PKG>_DEPENDENCIES} is handled specially:
    \begin{itemize}
    \item Derived automatically from \code{<PKG>_DEPENDENCIES}, after
      prepending \code{host-} to all dependencies.
    \item \code{FOO_DEPENDENCIES = bar host-baz} $\rightarrow$
      \code{HOST_FOO_DEPENDENCIES = host-bar host-baz}.
    \item Can be overridden if the dependencies of the host variant are
      different than the ones of the target variant.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Example 1: a pure build utility}
  \begin{itemize}
  \item {\em bison}, a general-purpose parser generator.
  \item Purely used as build dependency in packages
    \begin{itemize}
    \item \code{FBSET_DEPENDENCIES = host-bison host-flex}
    \end{itemize}
  \item No \code{Config.in.host}, not visible in \code{menuconfig}.
  \end{itemize}
  \begin{block}{package/bison/bison.mk}
    \begin{minted}[fontsize=\tiny]{make}
BISON_VERSION = 3.0.4
BISON_SOURCE = bison-$(BISON_VERSION).tar.xz
BISON_SITE = $(BR2_GNU_MIRROR)/bison
BISON_LICENSE = GPLv3+
BISON_LICENSE_FILES = COPYING
HOST_BISON_DEPENDENCIES = host-m4

$(eval $(host-autotools-package))
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Example 2: a flashing utility}

  \begin{itemize}
  \item \code{dfu-util}, to reflash devices support the USB DFU
    protocol. Typically used on a development PC.
  \item Not used as a build dependency of another package
    $\rightarrow$ visible in \code{menuconfig}.
  \end{itemize}
  \begin{block}{package/dfu-util/Config.in.host}
    \tiny
\begin{verbatim}
config BR2_PACKAGE_HOST_DFU_UTIL
        bool "host dfu-util"
        help
          Dfu-util is the host side implementation of the DFU 1.0
          specification of the USB forum. DFU is intended to download
          and upload firmware to devices connected over USB.

          http://dfu-util.gnumonks.org/
\end{verbatim}
  \end{block}

  \begin{block}{package/dfu-util/dfu-util.mk}
    \begin{minted}[fontsize=\tiny]{make}
DFU_UTIL_VERSION = 0.6
DFU_UTIL_SITE = http://dfu-util.gnumonks.org/releases
DFU_UTIL_LICENSE = GPLv2+
DFU_UTIL_LICENSE_FILES = COPYING

HOST_DFU_UTIL_DEPENDENCIES = host-libusb

$(eval $(host-autotools-package))
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Example 3: target and host of the same package}
  \begin{block}{package/e2tools/e2tools.mk}
    \begin{minted}[fontsize=\tiny]{make}
E2TOOLS_VERSION = 3158ef18a903ca4a98b8fa220c9fc5c133d8bdf6
E2TOOLS_SITE = $(call github,ndim,e2tools,$(E2TOOLS_VERSION))

# Source coming from GitHub, no configure included.
E2TOOLS_AUTORECONF = YES
E2TOOLS_LICENSE = GPLv2
E2TOOLS_LICENSE_FILES = COPYING
E2TOOLS_DEPENDENCIES = e2fsprogs
E2TOOLS_CONF_ENV = LIBS="-lpthread"
HOST_E2TOOLS_CONF_ENV = LIBS="-lpthread"

$(eval $(autotools-package))
$(eval $(host-autotools-package))
    \end{minted}
  \end{block}
\end{frame}

\setuplabframe
{New packages in Buildroot}
{
  \begin{itemize}
  \item Practical creation of several new packages in Buildroot, using
    the different package infrastructures.
  \end{itemize}
}

